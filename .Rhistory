# Spatial grid
x <- seq(-pi, pi, length.out = 50)
y <- seq(-pi, pi, length.out = 50)
X <- matrix(rep(x, each = length(y)), nrow = length(x))
Y <- matrix(rep(y, times = length(x)), nrow = length(x))
# Wave parameters
A_i <- 1.0;  A_e <- 0.8
k_i <- 2;    k_e <- 2.5
l_i <- 1.5;  l_e <- 1.8
omega_i <- 3; omega_e <- 2.7
phi <- pi / 4
# Time steps
T_seq <- seq(0, 2*pi, length.out = 20)
# Initialize plotly figure with frames
fig <- plot_ly(
type = "surface",
z = matrix(0, nrow = length(x), ncol = length(y)),  # initial dummy surface
x = x, y = y,
colorscale = "Viridis"
) %>%
layout(
title = "Interactive 4D Holographic Energy Tunnel",
scene = list(
xaxis = list(title = "X (spatial)"),
yaxis = list(title = "Y (spatial)"),
zaxis = list(title = "Amplitude / Energy")
),
updatemenus = list(
list(type = "buttons",
buttons = list(
list(label = "Play",
method = "animate",
args = list(NULL, list(frame = list(duration = 300, redraw = TRUE),
fromcurrent = TRUE))),
list(label = "Pause",
method = "animate",
args = list(NULL, list(frame = list(duration = 0, redraw = FALSE),
mode = "immediate")))
))
)
)
# Add frames for each time step
frames <- lapply(seq_along(T_seq), function(i) {
t <- T_seq[i]
# Internal and external waves
psi_i <- A_i * sin(k_i * X + l_i * Y - omega_i * t)
psi_e <- A_e * sin(k_e * X + l_e * Y - omega_e * t + phi)
# Resonant field and mind-energy
psi_r <- psi_i + psi_e + psi_i * psi_e
E_exp <- psi_r^2
# Temporal derivative (perception)
dpsi_r_dt <- -A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) -
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) -
(A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) * psi_e +
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) * psi_i)
E_per <- abs(dpsi_r_dt)
# Return frame
list(
name = paste0("t_", round(t,2)),
data = list(
list(
type = "surface",
z = E_exp,
x = x,
y = y,
colorscale = "Viridis",
cmin = 0, cmax = max(E_exp),
showscale = TRUE,
opacity = 0.8,
name = "Experience ψr²"
),
list(
type = "surface",
z = E_per,
x = x,
y = y,
colorscale = "Plasma",
cmin = 0, cmax = max(E_per),
showscale = TRUE,
opacity = 0.5,
name = "Perception |∂ψr/∂t|"
)
)
)
})
# Add frames to figure
fig <- fig %>% animation_opts(frame = 300, transition = 0, redraw = TRUE) %>%
animation_slider(currentvalue = list(prefix = "Time: ")) %>%
animation_button(x = 1, y = 0) %>%
plotly::config(displayModeBar = TRUE) %>%
plotly::frame(frames = frames)  # Correct way to attach frames
# Spatial grid
x <- seq(-pi, pi, length.out = 50)
y <- seq(-pi, pi, length.out = 50)
X <- matrix(rep(x, each = length(y)), nrow = length(x))
Y <- matrix(rep(y, times = length(x)), nrow = length(x))
# Wave parameters
A_i <- 1.0;  A_e <- 0.8
k_i <- 2;    k_e <- 2.5
l_i <- 1.5;  l_e <- 1.8
omega_i <- 3; omega_e <- 2.7
phi <- pi / 4
# Time steps
T_seq <- seq(0, 2*pi, length.out = 20)
# Prepare data for all frames
data_list <- list()
for (i in seq_along(T_seq)) {
t <- T_seq[i]
# Internal and external waves
psi_i <- A_i * sin(k_i * X + l_i * Y - omega_i * t)
psi_e <- A_e * sin(k_e * X + l_e * Y - omega_e * t + phi)
# Resonant field (experience)
psi_r <- psi_i + psi_e + psi_i * psi_e
E_exp <- psi_r^2
# Temporal derivative (perception)
dpsi_r_dt <- -A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) -
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) -
(A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) * psi_e +
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) * psi_i)
E_per <- abs(dpsi_r_dt)
# Store as a frame
data_list[[i]] <- list(
x = as.vector(X),
y = as.vector(Y),
z = as.vector(E_exp),
type = "scatter3d",
mode = "markers",
marker = list(
size = 3,
color = as.vector(E_exp),
colorscale = "Viridis",
showscale = TRUE
),
frame = paste0("t_", round(t, 2)),
name = paste0("Experience t=", round(t,2))
)
}
# Create plotly figure with frames
fig <- plot_ly() %>%
add_trace(
data = data_list[[1]],
x = ~x, y = ~y, z = ~z,
type = "scatter3d",
mode = "markers",
marker = list(size = 3, color = ~z, colorscale = "Viridis", showscale = TRUE)
) %>%
layout(
title = "Interactive 3D Holographic Energy Tunnel",
scene = list(
xaxis = list(title = "X (spatial)"),
yaxis = list(title = "Y (spatial)"),
zaxis = list(title = "Mind-Energy ψᵣ²")
),
updatemenus = list(
list(
type = "buttons",
buttons = list(
list(
label = "Play",
method = "animate",
args = list(NULL, list(frame = list(duration = 200, redraw = TRUE), fromcurrent = TRUE))
),
list(
label = "Pause",
method = "animate",
args = list(NULL, list(frame = list(duration = 0, redraw = FALSE), mode = "immediate"))
)
)
)
)
) %>%
animation_opts(frame = 200, transition = 0, redraw = TRUE) %>%
animation_slider(currentvalue = list(prefix = "Time: "))
# Spatial grid
x <- seq(-pi, pi, length.out = 30)
y <- seq(-pi, pi, length.out = 30)
X <- matrix(rep(x, each = length(y)), nrow = length(x))
Y <- matrix(rep(y, times = length(x)), nrow = length(x))
# Wave parameters
A_i <- 1.0;  A_e <- 0.8
k_i <- 2;    k_e <- 2.5
l_i <- 1.5;  l_e <- 1.8
omega_i <- 3; omega_e <- 2.7
phi <- pi / 4
# Time steps
T_seq <- seq(0, 2*pi, length.out = 20)
# Prepare data frame for animation
df <- data.frame()
for (t in T_seq) {
# Internal & external waves
psi_i <- A_i * sin(k_i * X + l_i * Y - omega_i * t)
psi_e <- A_e * sin(k_e * X + l_e * Y - omega_e * t + phi)
# Resonant field & energy
psi_r <- psi_i + psi_e + psi_i * psi_e
E_exp <- psi_r^2
# Temporal derivative (perception)
dpsi_r_dt <- -A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) -
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) -
(A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) * psi_e +
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) * psi_i)
E_per <- abs(dpsi_r_dt)
# Convert matrices to long format
df <- rbind(df,
data.frame(
X = as.vector(X),
Y = as.vector(Y),
E_exp = as.vector(E_exp),
E_per = as.vector(E_per),
t = t
))
}
# Interactive 3D dual-mode animation
fig <- plot_ly(df, x = ~X, y = ~Y, z = ~E_exp, color = ~E_exp,
frame = ~t, type = 'scatter3d', mode = 'markers',
marker = list(size = 3, colorscale = 'Viridis', showscale = TRUE),
name = "Experience ψr²") %>%
add_trace(z = ~E_per, color = ~E_per,
marker = list(size = 3, colorscale = 'Plasma', showscale = TRUE),
name = "Perception |∂ψr/∂t|") %>%
layout(scene = list(
xaxis = list(title = "X (spatial)"),
yaxis = list(title = "Y (spatial)"),
zaxis = list(title = "Amplitude / Energy")
)) %>%
animation_opts(frame = 200, transition = 0, redraw = TRUE) %>%
animation_slider(currentvalue = list(prefix = "Time: ")) %>%
animation_button(x = 1, y = 0)
fig
# Spatial grid
x <- seq(-pi, pi, length.out = 50)
y <- seq(-pi, pi, length.out = 50)
X <- matrix(rep(x, each = length(y)), nrow = length(x))
Y <- matrix(rep(y, times = length(x)), nrow = length(x))
# Wave parameters
A_i <- 1.0;  A_e <- 0.8
k_i <- 2;    k_e <- 2.5
l_i <- 1.5;  l_e <- 1.8
omega_i <- 3; omega_e <- 2.7
phi <- pi / 4
# Time steps
T_seq <- seq(0, 2*pi, length.out = 20)
# Precompute surfaces for all time steps
frames <- lapply(T_seq, function(t) {
# Internal & external waves
psi_i <- A_i * sin(k_i * X + l_i * Y - omega_i * t)
psi_e <- A_e * sin(k_e * X + l_e * Y - omega_e * t + phi)
# Resonant field (experience)
psi_r <- psi_i + psi_e + psi_i * psi_e
E_exp <- psi_r^2
# Temporal derivative (perception)
dpsi_r_dt <- -A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) -
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) -
(A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) * psi_e +
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) * psi_i)
E_per <- abs(dpsi_r_dt)
list(
name = paste0("t_", round(t,2)),
data = list(
# Experience tube
list(
type = "surface",
x = x, y = y, z = E_exp,
colorscale = "Viridis",
opacity = 0.8,
showscale = TRUE,
name = "Experience ψr²"
),
# Perception tube overlay
list(
type = "surface",
x = x, y = y, z = E_per,
colorscale = "Plasma",
opacity = 0.5,
showscale = TRUE,
name = "Perception |∂ψr/∂t|"
)
)
)
})
# Initial figure with first frame
fig <- plot_ly() %>%
add_surface(z = frames[[1]]$data[[1]]$z, x = x, y = y, colorscale = "Viridis", opacity = 0.8, showscale = TRUE, name = "Experience ψr²") %>%
add_surface(z = frames[[1]]$data[[2]]$z, x = x, y = y, colorscale = "Plasma", opacity = 0.5, showscale = TRUE, name = "Perception |∂ψr/∂t|") %>%
layout(
title = "Interactive Dual Holographic Energy Tubes",
scene = list(
xaxis = list(title = "X (spatial)"),
yaxis = list(title = "Y (spatial)"),
zaxis = list(title = "Amplitude / Energy")
),
updatemenus = list(
list(
type = "buttons",
buttons = list(
list(
label = "Play",
method = "animate",
args = list(NULL, list(frame = list(duration = 300, redraw = TRUE), fromcurrent = TRUE))
),
list(
label = "Pause",
method = "animate",
args = list(NULL, list(frame = list(duration = 0, redraw = FALSE), mode = "immediate"))
)
)
)
)
) %>%
animation_opts(frame = 300, transition = 0, redraw = TRUE) %>%
animation_slider(currentvalue = list(prefix = "Time: "))
library(plotly)
library(reshape2)
# Spatial grid
x <- seq(-pi, pi, length.out = 30)
y <- seq(-pi, pi, length.out = 30)
X <- matrix(rep(x, each = length(y)), nrow = length(x))
Y <- matrix(rep(y, times = length(x)), nrow = length(x))
# Wave parameters
A_i <- 1.0;  A_e <- 0.8
k_i <- 2;    k_e <- 2.5
l_i <- 1.5;  l_e <- 1.8
omega_i <- 3; omega_e <- 2.7
phi <- pi / 4
# Time steps
T_seq <- seq(0, 2*pi, length.out = 20)
# Prepare long-format data frame for plotly animation
df <- data.frame()
for (t in T_seq) {
psi_i <- A_i * sin(k_i * X + l_i * Y - omega_i * t)
psi_e <- A_e * sin(k_e * X + l_e * Y - omega_e * t + phi)
# Resonant field (experience) and temporal derivative (perception)
psi_r <- psi_i + psi_e + psi_i * psi_e
E_exp <- psi_r^2
dpsi_r_dt <- -A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) -
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) -
(A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) * psi_e +
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) * psi_i)
E_per <- abs(dpsi_r_dt)
temp <- data.frame(
X = rep(x, each = length(y)),
Y = rep(y, times = length(x)),
E_exp = as.vector(E_exp),
E_per = as.vector(E_per),
t = t
)
df <- rbind(df, temp)
}
# Melt data for dual surfaces
df_exp <- df[, c("X","Y","E_exp","t")]
colnames(df_exp)[3] <- "Z"
df_exp$Surface <- "Experience ψr²"
df_per <- df[, c("X","Y","E_per","t")]
colnames(df_per)[3] <- "Z"
df_per$Surface <- "Perception |∂ψr/∂t|"
df_all <- rbind(df_exp, df_per)
# Interactive 3D animation
fig <- plot_ly(df_all, x = ~X, y = ~Y, z = ~Z, color = ~Z,
frame = ~t, type = 'scatter3d', mode = 'markers',
colors = c("Experience ψr²"="Viridis","Perception |∂ψr/∂t|"="Plasma"),
marker = list(size = 3),
split = ~Surface) %>%
layout(
title = "Interactive Dual Holographic Energy Tubes",
scene = list(
xaxis = list(title = "X (spatial)"),
yaxis = list(title = "Y (spatial)"),
zaxis = list(title = "Amplitude / Energy")
)
) %>%
animation_opts(frame = 200, transition = 0, redraw = TRUE) %>%
animation_slider(currentvalue = list(prefix = "Time: "))
library(plotly)
library(reshape2)
# Spatial grid
x <- seq(-pi, pi, length.out = 30)
y <- seq(-pi, pi, length.out = 30)
X <- matrix(rep(x, each = length(y)), nrow = length(x))
Y <- matrix(rep(y, times = length(x)), nrow = length(x))
# Wave parameters
A_i <- 1.0;  A_e <- 0.8
k_i <- 2;    k_e <- 2.5
l_i <- 1.5;  l_e <- 1.8
omega_i <- 3; omega_e <- 2.7
phi <- pi / 4
# Time steps
T_seq <- seq(0, 2*pi, length.out = 20)
# Prepare long-format data frame for plotly animation
df <- data.frame()
for (t in T_seq) {
psi_i <- A_i * sin(k_i * X + l_i * Y - omega_i * t)
psi_e <- A_e * sin(k_e * X + l_e * Y - omega_e * t + phi)
# Resonant field (experience) and temporal derivative (perception)
psi_r <- psi_i + psi_e + psi_i * psi_e
E_exp <- psi_r^2
dpsi_r_dt <- -A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) -
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) -
(A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) * psi_e +
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) * psi_i)
E_per <- abs(dpsi_r_dt)
temp <- data.frame(
X = rep(x, each = length(y)),
Y = rep(y, times = length(x)),
E_exp = as.vector(E_exp),
E_per = as.vector(E_per),
t = t
)
df <- rbind(df, temp)
}
# Melt data for dual surfaces
df_exp <- df[, c("X","Y","E_exp","t")]
colnames(df_exp)[3] <- "Z"
df_exp$Surface <- "Experience ψr²"
df_per <- df[, c("X","Y","E_per","t")]
colnames(df_per)[3] <- "Z"
df_per$Surface <- "Perception |∂ψr/∂t|"
# Create plotly figure
fig <- plot_ly()
# Trace for Experience ψr²
fig <- fig %>%
add_markers(data = df_exp, x = ~X, y = ~Y, z = ~Z, frame = ~t,
color = ~Z, colors = "Viridis", marker = list(size = 3),
name = "Experience ψr²")
# Trace for Perception |∂ψr/∂t|
fig <- fig %>%
add_markers(data = df_per, x = ~X, y = ~Y, z = ~Z, frame = ~t,
color = ~Z, colors = "Plasma", marker = list(size = 3),
name = "Perception |∂ψr/∂t|")
# Layout and animation options
fig <- fig %>%
layout(title = "Interactive Dual Holographic Energy Tubes",
scene = list(xaxis = list(title = "X (spatial)"),
yaxis = list(title = "Y (spatial)"),
zaxis = list(title = "Amplitude / Energy"))) %>%
animation_opts(frame = 200, transition = 0, redraw = TRUE) %>%
animation_slider(currentvalue = list(prefix = "Time: "))
install.packages("viridis")
library(plotly)
library(reshape2)
library(viridis)  # For color palettes
# Spatial grid
x <- seq(-pi, pi, length.out = 30)
y <- seq(-pi, pi, length.out = 30)
X <- matrix(rep(x, each = length(y)), nrow = length(x))
Y <- matrix(rep(y, times = length(x)), nrow = length(x))
# Wave parameters
A_i <- 1.0;  A_e <- 0.8
k_i <- 2;    k_e <- 2.5
l_i <- 1.5;  l_e <- 1.8
omega_i <- 3; omega_e <- 2.7
phi <- pi / 4
# Time steps
T_seq <- seq(0, 2*pi, length.out = 20)
# Prepare long-format data frame for plotly animation
df <- data.frame()
for (t in T_seq) {
psi_i <- A_i * sin(k_i * X + l_i * Y - omega_i * t)
psi_e <- A_e * sin(k_e * X + l_e * Y - omega_e * t + phi)
# Resonant field (experience) and temporal derivative (perception)
psi_r <- psi_i + psi_e + psi_i * psi_e
E_exp <- psi_r^2
dpsi_r_dt <- -A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) -
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) -
(A_i * omega_i * cos(k_i * X + l_i * Y - omega_i * t) * psi_e +
A_e * omega_e * cos(k_e * X + l_e * Y - omega_e * t + phi) * psi_i)
E_per <- abs(dpsi_r_dt)
temp <- data.frame(
X = rep(x, each = length(y)),
Y = rep(y, times = length(x)),
E_exp = as.vector(E_exp),
E_per = as.vector(E_per),
t = t
)
df <- rbind(df, temp)
}
# Separate data for dual surfaces
df_exp <- df[, c("X","Y","E_exp","t")]
colnames(df_exp)[3] <- "Z"
df_exp$Surface <- "Experience ψr²"
df_per <- df[, c("X","Y","E_per","t")]
colnames(df_per)[3] <- "Z"
df_per$Surface <- "Perception |∂ψr/∂t|"
# Map colors using viridis palettes
# Discretize Z into bins for color mapping
n_colors_exp <- 100
n_colors_per <- 100
df_exp$color <- viridis::viridis(n_colors_exp)[
as.numeric(cut(df_exp$Z, breaks = n_colors_exp))]
df_per$color <- viridis::plasma(n_colors_per)[
as.numeric(cut(df_per$Z, breaks = n_colors_per))]
fig <- plot_ly()
# Experience trace with viridis colors
fig <- fig %>%
add_markers(data = df_exp, x = ~X, y = ~Y, z = ~Z, frame = ~t,
marker = list(size = 3, color = df_exp$color),
name = "Experience ψr²")
# Perception trace with plasma colors
fig <- fig %>%
add_markers(data = df_per, x = ~X, y = ~Y, z = ~Z, frame = ~t,
marker = list(size = 3, color = df_per$color),
name = "Perception |∂ψr/∂t|")
fig <- fig %>%
layout(
title = "Interactive Dual Holographic Energy Tubes",
scene = list(
xaxis = list(title = "X (spatial)"),
yaxis = list(title = "Y (spatial)"),
zaxis = list(title = "Amplitude / Energy")
)
) %>%
animation_opts(frame = 200, transition = 0, redraw = TRUE) %>%
animation_slider(currentvalue = list(prefix = "Time: "))
fig
